# emkyoot

Generate and run home automation projects written in Python. The `quicklaunch` subcommand will set up a minimal project in an empty directory. The next call to `quicklaunch` will refresh available device definitions, run some correctness checks using mypy and launch the project.

## Prerequisites

- Python 3.12+
- A working [zigbee2mqtt](https://www.zigbee2mqtt.io) instance.

## Quickstart

0) Set up a Python 3.12+ virtual environment.
1) Clone this repository into `EMKYOOT_GIT_DIRECTORY`
2) `pip install -e EMKYOOT_GIT_DIRECTORY`
2) Think about a `DIRECTORY` where you want to store your `config.toml` and `automation.py` files. These files will be autogenerated on the first run, if missing. You could also call `automation.py` anything else.
3) `emkyoot quicklaunch DIRECTORY/automation.py`

Follow the on-screen instructions. Everything, including the `automation.py` file will be autogenerated.

You can also find more information by issuing `emkyoot -h`.

## Examples

### A minimal example that does something

```
from emkyoot.message_loop import message_loop, MessageLoopTimer
from emkyoot_autogenerate.available_devices import AvailableDevices


def exit(timer: MessageLoopTimer):
    message_loop.stop()


exit_timer = MessageLoopTimer(exit)


def on_connect():
    devices.tokabo.brightness.set_normalized(1.0)
    exit_timer.start(0.5)


devices = AvailableDevices()
devices.on_connect.add_listener(on_connect)
```

When the connection to the MQTT server is made, all queryable parameters will automatically be queried. This can lead to a period of 5-10 seconds where zigbee2mqtt will not really respond to any further request. To avoid this we should use the `--skip_initial_query` argument to `emkyoot quicklaunch`. So the command to launch this snippet would be

```commandline
> emkyoot quicklaunch --skip_initial_query snippet.py
```

This example executes the `on_connect` function upon connecting to the MQTT server. Then it waits for half a second, to give time to the background message loop to send the brightness change to the server. Then it stops the `message_loop` which leads to the termination of the entire application. This leads into the topic of threading.

## About threading

User code should generally assume that it's running on the *message thread*. The message thread is the thread that belongs to the emkyoot `message_loop`.

The concept of the `message_loop` is necessary because it allows us to synchronize with the paho-mqtt thread, which is responsible for communicating with the MQTT server, and the flask thread, which is optionally present if a HTTP interface is provided using flask. It is useful, because it allows us to execute certain operations asynchronously. This allows emkyoot to collate multiple parameter updates into one and only communicate the changes to the MQTT server.

Because of this approach it is generally fine to make lots of parameter changes in automation code. Only parameters that are changed will result in communication with the MQTT server, and when many parameters change at once, they will often be communicated in as few messages as possible.

The key takeaway here, is that *callbacks exposed by emkyoot will be called on the message thread*. And parameter value changes should also be initiated from the message thread. So it's generally safe to access any public parameter function from any emkyoot callback function withouth the need for any synchronization.

Flask service callbacks however will be called on the flask thread and consequently they should be synchronized if they need to acces device parameters. You can use the `message_loop.post_message` function for this synchronization. Here's an example for this technique.

```
from flask import Flask, request

from automation import turn_off_everything, toggle_office
from emkyoot.message_loop import message_loop

app = Flask(__name__)


@app.route("/emkyoot/post", methods=["POST"])
def http_emkyoot_post():
    payload = request.get_json()

    def message_callback():
        http_message_handler(payload)

    message_loop.post_message(message_callback)

    return "", 200
```

The `message_callback` function and consequently the `http_message_handler` function will be called on the message thread, so no synchronization is necessary beyond that point.

## Debugging your automations

You can pass the `-v` or `--verbose` parameter to `quicklaunch` to set the logging level to `DEBUG`. For actual debugging with breakpoints and all, there are two options.

### Either import the command line interface in a Python script

This is the easiest way. Create a new source file in your project e.g. `run_automation.py` with the following contents.

```
from emkyoot import emkyoot

emkyoot(["quicklaunch", "DIRECTORY/automation.py"])
```

This is the same function that's called by the `emkyoot` command line utility, so you need to pass it the same parameters. You can run this Python script in an IDE and use break points to observe your code.

The `run_automation.py` script must not import your automation in any other way and shouldn't contain an `AvailableDevices` object for reasons. So it's best to keep it lean.

### Or import the quicklaunch function anywhere and call it directly

It's possible to `from emkyoot import quicklaunch` anywhere, including your main `automation.py` file. You need to pass your `AvailableDevices` object directly to the `quicklaunch` function. E.g. you could add this block of code at the end of `automation.py`.

```
if __name__ == "__main__":
    from emkyoot import quicklaunch, EmkyootConfig

    config = EmkyootConfig.load("config.toml")

    if config is not None:
        quicklaunch(devices, config)  # devices is the AvailableDevices object
```

The advantage of the other approach is that it will regenerate your `AvailableDevices` object *before* instantiating it. The advantage of this approach, is that it doesn't require a separate `.py` script.

## Under the hood

This section is meant to provide some information that can help with understanding failure cases.

The automation file you pass to `quicklaunch` will be imported using `importlib` The imported module's dictionary will be scanned for a `DevicesClient` object. An `AvailableDevices` object meets this criteria because it inherits from `DevicesClient`. This object will be attached to a message loop and will carry out all communications with the MQTT server.

A consequence is that *you should only have one `AvailableDevices(DevicesClient)` object in your automation module*. The instantiation doesn't have to happen inside `automation.py`. You could do it in another module, and just import the object in `automation.py`. The important thing is that the AvailableDevices object must be visible through the module that you pass to `quicklaunch`.

