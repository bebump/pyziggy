# pyziggy

Generate and run home automation projects written in Python. The `run` subcommand will set up a minimal project in an empty directory. The next call to `run` will refresh available device definitions, run some correctness checks using mypy and launch the project.

## Prerequisites

- Python 3.12+
- A working [zigbee2mqtt](https://www.zigbee2mqtt.io) instance.

## Quickstart

0) Set up a Python 3.12+ virtual environment.
1) Clone this repository into `EMKYOOT_GIT_DIRECTORY`
2) `pip install -e EMKYOOT_GIT_DIRECTORY`
2) Think about a `DIRECTORY` where you want to store your `config.toml` and `automation.py` files. These files will be autogenerated on the first run, if missing. You could also call `automation.py` anything else.
3) `pyziggy run DIRECTORY/automation.py`

Follow the on-screen instructions. Everything, including the `automation.py` file will be autogenerated.

You can also find more information by issuing `pyziggy -h`.

## Examples

### A minimal example that does something

```
from pyziggy.message_loop import message_loop, MessageLoopTimer
from pyziggy_autogenerate.available_devices import AvailableDevices


def exit(timer: MessageLoopTimer):
    message_loop.stop()


exit_timer = MessageLoopTimer(exit)


def on_connect():
    devices.tokabo.brightness.set_normalized(1.0)
    exit_timer.start(0.5)


devices = AvailableDevices()
devices.on_connect.add_listener(on_connect)
```

When the connection to the MQTT server is made, all queryable parameters will automatically be queried. This can lead to a period of 5-10 seconds where zigbee2mqtt will not really respond to any further request. To avoid this we should use the `--skip_initial_query` argument to `pyziggy run`. So the command to launch this snippet would be

```commandline
> pyziggy run --skip_initial_query snippet.py
```

This example executes the `on_connect` function upon connecting to the MQTT server. Then it waits for half a second, to give time to the background message loop to send the brightness change to the server. Then it stops the `message_loop` which leads to the termination of the entire application. This leads into the topic of threading.

## About threading

User code should generally assume that it's running on the *message thread*. The message thread is the thread that belongs to the pyziggy `message_loop`.

The concept of the `message_loop` is necessary because it allows us to synchronize with the paho-mqtt thread, which is responsible for communicating with the MQTT server, and the flask thread, which is optionally present if an HTTP interface is provided using flask. And it is useful, because it allows us to execute certain operations asynchronously. This allows pyziggy to collate multiple parameter updates into one and only communicate the changes to the MQTT server.

Because of this approach it is generally fine to make lots of parameter changes in automation code. Only parameters that are changed will result in communication with the MQTT server, and when many parameters change at once, they will often be communicated in as few messages as possible.

The key takeaway here, is that *callbacks exposed by pyziggy will be called on the message thread*. And parameter value changes should also be initiated from the message thread. So it's generally safe to access any public parameter function from any pyziggy callback without the need for additional synchronization.

The callback of `pyziggy.message_loop.MessageLoopTimer` is called on the message thread as well. But the callback of the built in `threading.Timer` is not, so don't use it without synchronization to access your devices.

Flask service callbacks e.g. will be called on the flask thread and consequently they should be synchronized if they need to acces device parameters. You can use the `message_loop.post_message` function for this synchronization. Here's an example for this technique.

```
from flask import Flask, request

from automation import turn_off_all_lights
from pyziggy.message_loop import message_loop

app = Flask(__name__)


def http_message_handler(payload):
    if "action" in payload:
        action = payload["action"]

        if action == "turn_off_all_lights":
            turn_off_all_lights()


@app.route("/pyziggy/post", methods=["POST"])
def http_pyziggy_post():
    payload = request.get_json()

    def message_callback():
        http_message_handler(payload)

    message_loop.post_message(message_callback)

    return "", 200
```

The `message_callback` function and consequently the `http_message_handler` function will be called on the message thread, so no synchronization is necessary beyond that point.

Another class that can be used either for synchronization, or for making a function call asynchronous, is `pyziggy.message_loop.AsyncUpdater`. You can call `AsyncUpdater._trigger_async_update()` from any thread and it will result in a call to `AsyncUpdater._handle_async_update()` on the message thread.

## Debugging your automations

You can pass the `-v` or `--verbose` parameter to `run` to set the logging level to `DEBUG`. For actual debugging with breakpoints and all, there are two options.

### Either import the command line interface in a Python script

This is the easiest way. Create a new source file in your project e.g. `run_automation.py` with the following contents.

```
from pyziggy import pyziggy

pyziggy(["run", "DIRECTORY/automation.py"])
```

This is the same function that's called by the `pyziggy` command line utility, so you need to pass it the same parameters. You can run this Python script in an IDE and use break points to observe your code.

The `run_automation.py` script must not import your automation in any other way and shouldn't contain an `AvailableDevices` object for reasons. So it's best to keep it lean.

### Or import the run function anywhere and call it directly

It's possible to `from pyziggy import run` anywhere, including your main `automation.py` file. You need to pass your `AvailableDevices` object directly to the `run` function. E.g. you could add this block of code at the end of `automation.py`.

```
if __name__ == "__main__":
    from pyziggy import run, EmkyootConfig

    config = EmkyootConfig.load("config.toml")

    if config is not None:
        run(devices, config)  # devices is the AvailableDevices object
```

The advantage of the other approach is that it will regenerate your `AvailableDevices` object *before* instantiating it. The advantage of this approach, is that it doesn't require a separate `.py` script.

## Under the hood

This section is meant to provide some information that can help with understanding failure cases.

The automation file you pass to `run` will be imported using `importlib` The imported module's dictionary will be scanned for a `DevicesClient` object. An `AvailableDevices` object meets this criteria because it inherits from `DevicesClient`. This object will be attached to a message loop and will carry out all communications with the MQTT server.

A consequence is that *you should only have one `AvailableDevices(DevicesClient)` object in your automation module*. The instantiation doesn't have to happen inside `automation.py`. You could do it in another module, and just import the object in `automation.py`. The important thing is that the AvailableDevices object must be visible through the module that you pass to `run`.

