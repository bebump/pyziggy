# emkyoot - Run automation scripts that interact with zigbee2mqtt.
# Copyright (C) 2025  Attila Szarvas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

from .device_bases import LightWithColor
from .devices_client import DevicesClient
from .parameters import EnumParameter
from .parser import NumericParameterDefinition


# ==============================================================================
# These functions will adjust the generated AvailableDevices object before
# connecting to the MQTT service.
#
# They are necessary for my use cases, but I'm not confident enough about their
# general applicability, hence the name, workarounds.
#
# One of them changes the minimum and maximum values for hue and saturation
# sub-parameters in LightWithColor devices. These minimum and maximum values
# should ideally be reported by zigbee2mqtt, but for some reason they seem to be
# missing for all sub-parameters of composite parameters. After some
# experimentation, one can discover that the effective limits are [0, 360] for
# hue, and [0, 100] for saturation. I wouldn't be surprised if zigbee2mqtt
# eventually started reporting these limits, at which point they would
# automatically show up in the autogenerated LightWithColor devices.
#
# You can disable these workarounds by accessing the emkyoot.workarounds
# singleton object in your automation script.
#
# For example:
#
#     import emkyoot.workarounds
#     emkyoot.workarounds.fix_light_with_color_min_max_values.set_enabled(False)
#
# ==============================================================================


class Workaround:
    def __init__(self, callable, description: str):
        self._enabled = True
        self._callable = callable
        self._description = description

    def set_enabled(self, enabled: bool):
        self._enabled = enabled


def fix_light_with_color_min_max_values(dc: DevicesClient):
    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            if (
                device.color_hs.hue._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.hue._min_value = 0
            if (
                device.color_hs.hue._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.hue._max_value = 360
            if (
                device.color_hs.saturation._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.saturation._min_value = 0
            if (
                device.color_hs.saturation._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.saturation._max_value = 100


def make_action_enum_parameters_use_sync_callbacks(dc: DevicesClient):
    for device in dc.get_devices():
        for parameter in device.get_parameters():
            if (
                isinstance(parameter, EnumParameter)
                and parameter.get_property_name() == "action"
            ):
                parameter.set_use_synchronous_broadcast(True)


def make_setting_color_invalidate_color_temp(dc: DevicesClient):
    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            device.color_hs.add_listener(
                lambda: [
                    device.color_temp.mark_as_stale(),
                    device.color_xy.mark_as_stale(),
                ]
            )
            device.color_xy.add_listener(
                lambda: [
                    device.color_temp.mark_as_stale(),
                    device.color_hs.mark_as_stale(),
                ]
            )
            device.color_temp.add_listener(
                lambda: [
                    device.color_hs.mark_as_stale(),
                    device.color_xy.mark_as_stale(),
                ]
            )


class Workarounds:
    def __init__(self):
        self.fix_light_with_color_min_max_values = Workaround(
            fix_light_with_color_min_max_values,
            "Modifying LightWithColor devices. Changing hue limits to [0, 360] and saturation limits to [0, 100].",
        )
        self.make_setting_color_invalidate_color_temp = Workaround(
            make_setting_color_invalidate_color_temp,
            "Modifying LightWithColor devices. Setting hs, xy or color_temp will invalidate the other two.",
        )
        self.make_action_enum_parameters_use_sync_callbacks = Workaround(
            make_action_enum_parameters_use_sync_callbacks,
            'Modifying EnumParameters with the "action" property to use synchronous callbacks.',
        )

    def _get_workarounds(self) -> list[Workaround]:
        workarounds: list[Workaround] = []

        for k, v in vars(self).items():
            if isinstance(v, Workaround):
                workarounds.append(v)

        return workarounds

    def _apply(self, dc: DevicesClient):
        if not any([wa._enabled for wa in self._get_workarounds()]):
            return

        print(
            "Applying workarounds. See the documentation in the emkyoot.workarounds module if you want to disable them."
        )

        for wa in self._get_workarounds():
            if not wa._enabled:
                continue

            print(f"* {wa._description}")
            wa._callable(dc)


workarounds = Workarounds()
